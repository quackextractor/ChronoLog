<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ChronoLog Viewer</title>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { padding: 20px; background: #f8f9fa; }
.timeline-entry { padding: 10px; border-bottom: 1px solid #e6e6e6; font-family: monospace; white-space: pre-wrap; }
.timeline-entry.error   { background: #fbeaea; }
.timeline-entry.warning { background: #fff7e6; }
.timeline-entry.info    { background: #eef9ff; }
.small-muted { color: #666; font-size: .9rem; }
</style>
</head>
<body>
<div class="container">
    <h1 class="mb-3">ChronoLog Viewer</h1>

    <div class="row mb-3">
        <div class="col-md-6">
            <div class="card p-3">
                <h5 class="card-title">Latency (last N)</h5>
                <canvas id="latencyChart" height="160"></canvas>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card p-3">
                <h5 class="card-title">Counts</h5>
                <canvas id="eventChart" height="160"></canvas>
            </div>
        </div>
    </div>

    <div class="card p-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
            <div>
                <button id="prev-page" class="btn btn-sm btn-outline-secondary">Prev</button>
                <button id="next-page" class="btn btn-sm btn-outline-secondary">Next</button>
                <span id="page-info" class="ms-2 small-muted">Page 1</span>
            </div>
            <div>
                <label class="me-2 small-muted">Per page</label>
                <select id="per-page" class="form-select form-select-sm d-inline-block" style="width:80px;">
                    <option>10</option>
                    <option selected>30</option>
                    <option>50</option>
                    <option>100</option>
                </select>
            </div>
        </div>

        <div id="timeline-container" style="height:420px; overflow:auto;"></div>
    </div>
</div>

<script>
/*
 - Page-based timeline that only requests events (skips template lines).
 - Chart shows last N latency points from /timeseries.
 - Templates are rendered by replacing timestamp-prefix pattern and {num} with ellipsis.
 - NOTE: original numeric values inside template lines are removed by writer, so we cannot
   reconstruct them. We show templates as human-readable placeholders instead.
*/

let templates = {};
let currentPage = 1;
let perPage = parseInt(document.getElementById('per-page').value, 10) || 30;
let totalEvents = null; // will read from summary.timeline_count
let latencyChart = null, eventChart = null;

async function fetchJSON(path) {
    const resp = await fetch(path);
    if (!resp.ok) throw new Error('fetch failed ' + path);
    return resp.json();
}

function humanizeTemplate(t) {
    if (!t) return "";
    // remove typical leading timestamp pattern with hyphens and spaces, like "{num}-{num}-{num} {num}:{num}:{num} "
    t = t.replace(/^\{num\}-\{num\}-\{num\}\s+\{num\}:\{num\}:\{num\}\s+/, '');
    // replace {num} with ellipsis
    t = t.replace(/\{num\}/g, '…');
    return t;
}

function resolveMessage(e) {
    // If the entry carries a msg_id, resolve to the template (we can't restore numbers)
    if (e.msg_id !== undefined && templates[String(e.msg_id)] !== undefined) {
        return humanizeTemplate(templates[String(e.msg_id)]);
    }
    // If it has value, show value
    if (e.value !== undefined) {
        return String(e.value);
    }
    // fallback to any raw msg if present
    if (e.msg) return e.msg;
    return '';
}

function renderTimeline(entries) {
    const container = document.getElementById('timeline-container');
    container.innerHTML = '';
    if (!entries || entries.length === 0) {
        container.innerHTML = '<div class="p-3 small-muted">No events on this page.</div>';
        return;
    }

    const frag = document.createDocumentFragment();
    entries.forEach(e => {
        const d = document.createElement('div');
        d.className = 'timeline-entry ' + (e.event||'info');
        const time = e.time ? `[${e.time}] ` : '';
        const msg = resolveMessage(e);
        d.innerHTML = `<div><strong>${time}${(e.event||'').toUpperCase()}</strong></div>
                       <div class="small-muted">${msg}</div>`;
        frag.appendChild(d);
    });
    container.appendChild(frag);
}

async function loadTemplates() {
    try {
        templates = await fetchJSON('/messages');
        // normalize keys to strings for consistent indexing
        const normalized = {};
        Object.entries(templates).forEach(([k,v]) => normalized[String(k)] = v);
        templates = normalized;
    } catch (err) {
        templates = {};
    }
}

async function loadSummaryAndCharts() {
    try {
        const s = await fetchJSON('/summary');
        if (s && s.timeline_count !== undefined) totalEvents = s.timeline_count;
        // build/refresh charts
        // latency timeseries last N points
        const points = await fetchJSON('/timeseries?metric=latency&limit=500');
        const labels = points.map(p => p.time);
        const values = points.map(p => p.value);

        // latency chart
        if (!latencyChart) {
            const ctx = document.getElementById('latencyChart').getContext('2d');
            latencyChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets: [{ label: 'latency (ms)', data: values, fill:false, pointRadius:1 }] },
                options: { scales: { x: { display: !!labels.length, ticks:{maxRotation:0} } }, plugins:{legend:{display:false}} }
            });
        } else {
            latencyChart.data.labels = labels;
            latencyChart.data.datasets[0].data = values;
            latencyChart.update();
        }

        // event counts bar chart
        const errors = s && s.summary ? (s.summary.error_count||0) : 0;
        const warnings = s && s.summary ? (s.summary.warning_count||0) : 0;
        if (!eventChart) {
            const ctx2 = document.getElementById('eventChart').getContext('2d');
            eventChart = new Chart(ctx2, {
                type: 'bar',
                data: { labels: ['errors','warnings'], datasets: [{ label:'count', data: [errors,warnings] }] },
                options: { plugins:{legend:{display:false}} }
            });
        } else {
            eventChart.data.datasets[0].data = [errors,warnings];
            eventChart.update();
        }
    } catch (err) {
        console.warn('chart load failed', err);
    }
}

async function loadTimelinePage(page, per_page) {
    const resp = await fetch(`/timeline?page=${page}&per_page=${per_page}`);
    if (!resp.ok) return [];
    return resp.json();
}

async function refreshPage() {
    perPage = parseInt(document.getElementById('per-page').value, 10);
    // clamp page to available pages if we know totalEvents
    if (totalEvents !== null) {
        const maxPage = Math.max(1, Math.ceil(totalEvents / perPage));
        if (currentPage > maxPage) currentPage = maxPage;
    }
    // load small things in parallel
    await loadTemplates();
    const [entries] = await Promise.all([ loadTimelinePage(currentPage, perPage) ]);
    renderTimeline(entries);
    await loadSummaryAndCharts();
    updatePagerUI();
}

function updatePagerUI() {
    const info = document.getElementById('page-info');
    let txt = `Page ${currentPage}`;
    if (totalEvents !== null) {
        const maxPage = Math.max(1, Math.ceil(totalEvents / perPage));
        txt += ` of ${maxPage}`;
        document.getElementById('prev-page').disabled = (currentPage <= 1);
        document.getElementById('next-page').disabled = (currentPage >= maxPage);
    } else {
        document.getElementById('prev-page').disabled = (currentPage <= 1);
        document.getElementById('next-page').disabled = false;
    }
    info.textContent = txt;
}

// wire controls
document.getElementById('prev-page').addEventListener('click', () => {
    if (currentPage > 1) { currentPage--; refreshPage(); }
});
document.getElementById('next-page').addEventListener('click', () => {
    currentPage++; refreshPage();
});
document.getElementById('per-page').addEventListener('change', () => {
    currentPage = 1;
    refreshPage();
});

// initial load
refreshPage();
</script>
</body>
</html>
