<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ChronoLog Viewer</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            padding: 20px;
            background: #f8f9fa;
        }

        .timeline-entry {
            padding: 10px;
            border-bottom: 1px solid #e6e6e6;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .timeline-entry.error {
            background: #fbeaea;
        }

        .timeline-entry.warning {
            background: #fff7e6;
        }

        .timeline-entry.info {
            background: #eef9ff;
        }

        .small-muted {
            color: #666;
            font-size: .9rem;
        }

        .msg-charts {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch;
        }

        .msg-card {
            width: 320px;
            flex: 0 0 320px;
        }

        .msg-card canvas {
            width: 100%;
            height: 140px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 class="mb-3">ChronoLog Viewer</h1>

        <div class="row mb-3">
            <div class="col-md-6">
                <div class="card p-3">
                    <h5 class="card-title">Latency (last N)</h5>
                    <canvas id="latencyChart" height="160"></canvas>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card p-3">
                    <h5 class="card-title">Counts</h5>
                    <canvas id="eventChart" height="160"></canvas>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <div class="card p-3">
                <h5 class="card-title mb-2">Message metrics (per-template charts)</h5>
                <div id="messageCharts" class="msg-charts">
                    <!-- message charts will be appended here -->
                </div>
            </div>
        </div>

        <div class="card p-3">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <div>
                    <button id="prev-page" class="btn btn-sm btn-outline-secondary">Prev</button>
                    <button id="next-page" class="btn btn-sm btn-outline-secondary">Next</button>
                    <span id="page-info" class="ms-2 small-muted">Page 1</span>
                </div>
                <div>
                    <label class="me-2 small-muted">Per page</label>
                    <select id="per-page" class="form-select form-select-sm d-inline-block" style="width:80px;">
                        <option>10</option>
                        <option selected>30</option>
                        <option>50</option>
                        <option>100</option>
                    </select>
                </div>
            </div>

            <div id="timeline-container" style="height:420px; overflow:auto;"></div>
        </div>
    </div>

    <script>

        let templates = {};
        let currentPage = 1;
        let perPage = parseInt(document.getElementById('per-page').value, 10) || 30;
        let totalEvents = null; // will read from summary.timeline_count
        let latencyChart = null, eventChart = null;
        const messageCharts = {}; // id -> Chart instance

        async function fetchJSON(path) {
            const resp = await fetch(path);
            if (!resp.ok) throw new Error('fetch failed ' + path);
            return resp.json();
        }

        function humanizeTemplate(t) {
            if (!t) return "";
            // remove typical leading timestamp pattern with hyphens and spaces, like "{num}-{num}-{num} {num}:{num}:{num} "
            t = t.replace(/^\{num\}-\{num\}-\{num\}\s+\{num\}:\{num\}:\{num\}\s+/, '');
            // replace {num} with ellipsis
            t = t.replace(/\{num\}/g, '…');
            return t;
        }

        function interpolateTemplate(t, vals) {
            if (!t) return "";
            let i = 0;
            return t.replace(/\{num\}/g, () => {
                if (Array.isArray(vals) && i < vals.length) {
                    const v = vals[i++];
                    return String(v);
                }
                i++;
                return '…';
            });
        }

        function resolveMessage(e) {
            // If the entry carries a msg_id, resolve to the template and inject msg_values if present
            if (e.msg_id !== undefined && templates[String(e.msg_id)] !== undefined) {
                const tpl = templates[String(e.msg_id)];
                if (Array.isArray(e.msg_values) && e.msg_values.length > 0) {
                    // reconstruct numeric placeholders with provided values
                    return interpolateTemplate(tpl, e.msg_values);
                }
                // no values: show a human-friendly template (numbers elided)
                return humanizeTemplate(tpl);
            }
            // If it has value, show value
            if (e.value !== undefined) {
                return String(e.value);
            }
            // fallback to any raw msg if present
            if (e.msg) return e.msg;
            return '';
        }

        function renderTimeline(entries) {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';
            if (!entries || entries.length === 0) {
                container.innerHTML = '<div class="p-3 small-muted">No events on this page.</div>';
                return;
            }

            const frag = document.createDocumentFragment();
            entries.forEach(e => {
                const d = document.createElement('div');
                d.className = 'timeline-entry ' + (e.event || 'info');
                const time = e.time ? `[${e.time}] ` : '';
                const msg = resolveMessage(e);
                d.innerHTML = `<div><strong>${time}${(e.event || '').toUpperCase()}</strong></div>
                       <div class="small-muted">${escapeHtml(msg)}</div>`;
                frag.appendChild(d);
            });
            container.appendChild(frag);
        }

        function escapeHtml(s) {
            if (!s) return '';
            return s.replace(/[&<>"']/g, function (m) { return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]); });
        }

        async function loadTemplates() {
            try {
                templates = await fetchJSON('/api/messages');
                // normalize keys to strings for consistent indexing
                const normalized = {};
                Object.entries(templates).forEach(([k, v]) => normalized[String(k)] = v);
                templates = normalized;
            } catch (err) {
                templates = {};
            }
        }

        async function loadSummaryAndCharts() {
            try {
                const s = await fetchJSON('/api/summary');
                if (s && s.timeline_count !== undefined) totalEvents = s.timeline_count;

                // latency timeseries last N points
                const points = await fetchJSON('/api/timeseries?metric=latency&limit=500');
                const labels = points.map(p => p.time);
                const values = points.map(p => p.value);

                // latency chart
                if (!latencyChart) {
                    const ctx = document.getElementById('latencyChart').getContext('2d');
                    latencyChart = new Chart(ctx, {
                        type: 'line',
                        data: { labels, datasets: [{ label: 'latency (ms)', data: values, fill: false, pointRadius: 1 }] },
                        options: { scales: { x: { display: !!labels.length, ticks: { maxRotation: 0 } } }, plugins: { legend: { display: false } } }
                    });
                } else {
                    latencyChart.data.labels = labels;
                    latencyChart.data.datasets[0].data = values;
                    latencyChart.update();
                }

                // event counts bar chart
                const errors = s ? (s.error_count || 0) : 0;
                const warnings = s ? (s.warning_count || 0) : 0;
                if (!eventChart) {
                    const ctx2 = document.getElementById('eventChart').getContext('2d');
                    eventChart = new Chart(ctx2, {
                        type: 'bar',
                        data: { labels: ['errors', 'warnings'], datasets: [{ label: 'count', data: [errors, warnings] }] },
                        options: { plugins: { legend: { display: false } } }
                    });
                } else {
                    eventChart.data.datasets[0].data = [errors, warnings];
                    eventChart.update();
                }

                // per-message charts: for each template try to fetch timeseries; create chart if any points
                const msgContainer = document.getElementById('messageCharts');
                // keep track of which ids we saw this round; remove obsolete charts
                const seenIds = new Set();

                const templateIds = Object.keys(templates || {});
                await Promise.all(templateIds.map(async (id) => {
                    try {
                        const points = await fetchJSON(`/api/timeseries?metric=msg_${id}&limit=500`);
                        if (!points || points.length === 0) {
                            return;
                        }
                        seenIds.add(id);
                        // prepare labels/values
                        const labels = points.map(p => p.time);
                        const values = points.map(p => p.value);

                        // create container/card for this chart if not exists
                        let card = document.getElementById(`msg-card-${id}`);
                        if (!card) {
                            card = document.createElement('div');
                            card.className = 'card p-2 msg-card';
                            card.id = `msg-card-${id}`;
                            card.innerHTML = `<div class="small-muted mb-1">${escapeHtml(humanizeTemplate(templates[id]))}</div>
                                      <canvas id="msgChart-${id}"></canvas>`;
                            msgContainer.appendChild(card);
                        }
                        const ctx = document.getElementById(`msgChart-${id}`).getContext('2d');

                        // update or create chart instance
                        if (!messageCharts[id]) {
                            messageCharts[id] = new Chart(ctx, {
                                type: 'line',
                                data: { labels, datasets: [{ label: `msg_${id}`, data: values, fill: false, pointRadius: 1 }] },
                                options: { plugins: { legend: { display: false } }, scales: { x: { display: false } } }
                            });
                        } else {
                            messageCharts[id].data.labels = labels;
                            messageCharts[id].data.datasets[0].data = values;
                            messageCharts[id].update();
                        }
                    } catch (err) {
                        // ignore per-message errors
                        console.warn('message chart load failed for id', id, err);
                    }
                }));

                // remove any message chart DOM + chart object for ids not seen
                Object.keys(messageCharts).forEach(existingId => {
                    if (!seenIds.has(existingId)) {
                        // destroy chart and remove element
                        try {
                            messageCharts[existingId].destroy();
                        } catch (e) { }
                        delete messageCharts[existingId];
                        const el = document.getElementById(`msg-card-${existingId}`);
                        if (el && el.parentNode) el.parentNode.removeChild(el);
                    }
                });

            } catch (err) {
                console.warn('chart load failed', err);
            }
        }

        async function loadTimelinePage(page, per_page) {
            const resp = await fetch(`/api/timeline?page=${page}&per_page=${per_page}`);
            if (!resp.ok) return [];
            return resp.json();
        }

        async function refreshPage() {
            perPage = parseInt(document.getElementById('per-page').value, 10);
            // clamp page to available pages if we know totalEvents
            if (totalEvents !== null) {
                const maxPage = Math.max(1, Math.ceil(totalEvents / perPage));
                if (currentPage > maxPage) currentPage = maxPage;
            }
            // load small things in parallel
            await loadTemplates();
            const [entries] = await Promise.all([loadTimelinePage(currentPage, perPage)]);
            renderTimeline(entries);
            await loadSummaryAndCharts();
            updatePagerUI();
        }

        function updatePagerUI() {
            const info = document.getElementById('page-info');
            let txt = `Page ${currentPage}`;
            if (totalEvents !== null) {
                const maxPage = Math.max(1, Math.ceil(totalEvents / perPage));
                txt += ` of ${maxPage}`;
                document.getElementById('prev-page').disabled = (currentPage <= 1);
                document.getElementById('next-page').disabled = (currentPage >= maxPage);
            } else {
                document.getElementById('prev-page').disabled = (currentPage <= 1);
                document.getElementById('next-page').disabled = false;
            }
            info.textContent = txt;
        }

        // wire controls
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage > 1) { currentPage--; refreshPage(); }
        });
        document.getElementById('next-page').addEventListener('click', () => {
            currentPage++; refreshPage();
        });
        document.getElementById('per-page').addEventListener('change', () => {
            currentPage = 1;
            refreshPage();
        });

        // initial load
        refreshPage();
    </script>
</body>

</html>